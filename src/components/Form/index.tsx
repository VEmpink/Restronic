import React, {useContext, useEffect, useRef} from 'react';
import {View} from 'react-native';

import {NavigationProp, useNavigation} from '@react-navigation/native';
import {Icon, Button} from '@ui-kitten/components';
import _ from 'lodash';

import {RealmContext} from '../../context';
import {validateCustomerData} from '../../schema/joi.schema';
import {RootStackParamList} from '../../types';
import util from '../../utils';

import FowardedFirstColumnInputs, {
  FirstColumnInputMethods,
} from './Inputs/FirstColumnInputs';
import FowardedSecondColumnInputs, {
  SecondColumnInputMethods,
} from './Inputs/SecondColumnInputs';
import FowardedThirdColumnInputs, {
  ThirdColumnInputMethods,
} from './Inputs/ThirdColumnInputs';

type BodyMainFormProps = {
  isEditMode: boolean;
  selectedCustomerId: number;
};

function BodyMainForm(props: BodyMainFormProps): React.ReactElement {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const {isEditMode, selectedCustomerId} = props;
  const {Realm} = useContext(RealmContext);

  const firstColumnInputRefs = useRef<FirstColumnInputMethods>(null);
  const secondColumnInputRefs = useRef<SecondColumnInputMethods>(null);
  const thirdColumnInputRefs = useRef<ThirdColumnInputMethods>(null);

  useEffect(() => {
    if (isEditMode) {
      const customer = Realm.objects('customers')
        .filtered(`_id = ${selectedCustomerId}`)
        .toJSON()[0];

      firstColumnInputRefs.current?.setInputData(
        _.pick(customer, ['createdAt', 'name', 'photo', 'deviceBrand']),
      );
      secondColumnInputRefs.current?.setInputData(
        _.pick(customer, [
          'deviceName',
          'deviceColor',
          'deviceDamage',
          'timeEstimate',
        ]),
      );
      thirdColumnInputRefs.current?.setInputData(
        _.pick(customer, ['servicePrice', 'serviceDownPayment', 'notes']),
      );
    }
  }, []);

  return (
    <>
      <FowardedFirstColumnInputs
        onSubmitAtLastField={() => secondColumnInputRefs.current?.focus()}
        ref={firstColumnInputRefs}
      />

      <FowardedSecondColumnInputs
        onSubmitAtLastField={() => thirdColumnInputRefs.current?.focus()}
        ref={secondColumnInputRefs}
      />

      <FowardedThirdColumnInputs ref={thirdColumnInputRefs} />

      <View style={{flex: 1, alignItems: 'flex-end'}}>
        <Button
          status={isEditMode ? 'warning' : 'primary'}
          accessoryLeft={(propsAcc) => (
            <Icon
              {...propsAcc}
              name={isEditMode ? 'edit-outline' : 'person-add-outline'}
            />
          )}
          onPress={async () => {
            try {
              const formData = {
                /**
                 * Added by User
                 */
                ...firstColumnInputRefs.current?.getInputData(),
                ...secondColumnInputRefs.current?.getInputData(),
                ...thirdColumnInputRefs.current?.getInputData(),

                /**
                 * Added by Server
                 */
                _id: Date.now(),
                updatedAt: Date.now(),
                serviceStatus: 'onprocess',
                serviceFinishDate: Date.now(),
                timeWarranty: 0,
              };

              const validFormData = await validateCustomerData(formData);

              Realm.write(() => {
                if (!isEditMode) {
                  Realm.create('customers', validFormData);

                  firstColumnInputRefs.current?.resetValues();
                  secondColumnInputRefs.current?.resetValues();
                  thirdColumnInputRefs.current?.resetValues();

                  util.snackbar.show('success', 'Data berhasil ditambahkan!');
                } else {
                  const customer = Realm.objects('customers').filtered(
                    `_id = ${selectedCustomerId}`,
                  );

                  /**
                   * All this object property is auto generated by system,
                   * so the value will be dynamic and comparing object will
                   * be always "false" or not the same.
                   */
                  const copyCustomer = customer.toJSON()[0];
                  delete copyCustomer._id;
                  delete copyCustomer.updatedAt;
                  delete copyCustomer.serviceStatus;
                  delete copyCustomer.serviceFinishDate;
                  delete copyCustomer.timeWarranty;

                  const copyValidFormData = validFormData;
                  delete copyValidFormData._id;
                  delete copyValidFormData.updatedAt;
                  delete copyValidFormData.serviceStatus;
                  delete copyValidFormData.serviceFinishDate;
                  delete copyValidFormData.timeWarranty;

                  /**
                   * Prevent user change customer data with the same value
                   */
                  if (_.isEqual(copyValidFormData, copyCustomer)) {
                    util.snackbar.show('warning', 'Tidak ada yang diubah!');
                  } else {
                    /**
                     * Update all customer property except the "_id"
                     */
                    Object.keys(validFormData).forEach((key) => {
                      if (key !== '_id') {
                        customer.update(
                          key,
                          key === 'updatedAt' ? Date.now() : validFormData[key],
                        );
                      }
                    });

                    util.snackbar.show('success', 'Data berhasil diubah!');
                    navigation.goBack();
                  }
                }
              });
            } catch (error) {
              if (error.name === 'ValidationError') {
                const errorObjPropName = error.details[0].context.label;
                firstColumnInputRefs.current?.setFieldError(errorObjPropName);
                secondColumnInputRefs.current?.setFieldError(errorObjPropName);

                util.snackbar.show('error', error.details[0].message);
              } else {
                util.snackbar.show(
                  'error',
                  isEditMode
                    ? 'Gagal mengubah data pelanggan!'
                    : 'Gagal menambahkan data pelanggan!',
                  false,
                );
              }
            }
          }}
        >
          {isEditMode ? 'Ubah data' : 'Tambahkan'}
        </Button>
      </View>
    </>
  );
}

export default BodyMainForm;
